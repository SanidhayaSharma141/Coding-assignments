{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Bare minimum C program": {
	 	"prefix": "main2",
	 	"body": [
			"//name: Sanidhaya sharma Roll no.:CS21B1024",
			"//Problem 1",
	 		"#include<stdio.h>",
			"#include<string.h>",
			"#include<stdlib.h>",
	 		"int main(void)",
			"{",
			"\tint num,i,j,k,l,a,b,c;",
			"\tscanf($1);",
			"\t",
			"\treturn 0;",
			"}"
	 	],
	 	"description": "C program"
		},
		"enqueuesingle": {
			"prefix": "linear queue enqueue",
			"body": [
				"void enqueue(int data){\r",
				"    node* ptr=malloc(sizeof(node));//declared node that will store the data\r",
				"    ptr->data=data;\r",
				"    ptr->next=NULL;\r",
				"    if((front==NULL)&&(end==NULL)){//empty stack condition\r",
				"        front=ptr;\r",
				"        end=ptr;\r",
				"    }\r",
				"    else{\r",
				"        end->next=ptr;\r",
				"        end=end->next;//now top will point to the newly added node\r",
				"    }\r",
				"}"
			]
		},
		"dequeuesingle": {
			"prefix": "dequeue in linear queue",
			"body": [
				"int dequeue(){\r",
				"    node* temp=front;\r",
				"    if(front==NULL){//empty stack condition\r",
				"        printf(\"empty queue\\n\");\r",
				"        c=0;\r",
				"        return -1;\r",
				"    }\r",
				"    else{\r",
				"        c=1;\r",
				"        // printf(\"%d\",top->data);\r",
				"        int x=front->data;\r",
				"        front=front->next;\r",
				"        if(front==NULL){\r",
				"            end=NULL;\r",
				"        }\r",
				"\r",
				"        free(temp);\r",
				"        return(x);\r",
				"    }\r",
				"}"
			]
		},
		"queue make": {
			"prefix": "struct queue",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"struct Node \r",
				"{\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *front=NULL;\r",
				"node *end=NULL;"
			]
		},
		"print linear queue": {
			"prefix": "linear queue print",
			"body": [
				"// note: use this to see changesin queue\r",
				"void print(){\r",
				"    if((front==NULL)&&(end==NULL)){\r",
				"        printf(\"queue empty\");\r",
				"    }\r",
				"    else{\r",
				"        printf(\" front: %d\\n\",front->data);\r",
				"         printf(\" end: %d\\n\",end->data);\r",
				"   for(node* tempp=front;tempp!=NULL;tempp=tempp->next){\r",
				"       printf(\"%d \",tempp->data );\r",
				"   }\r",
				"   printf(\"\\n\");}\r",
				"}"
			]
		},
		"main fxn ques": {
			"prefix": "main fxn for input",
			"body": [
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    int value;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='e'){\r",
				"            scanf(\"%d\" ,&data);//element to be pushed in stack taken as input\r",
				"            enqueue(data);//calling function\r",
				"        }\r",
				"        else if (func=='d'){\r",
				"            value=dequeue();//calling function\r",
				"            if(c==1){printf(\"%d\\n\",value);}\r",
				"        }\r",
				"        // else if(func=='t'){\r",
				"        //     print();\r",
				"        // }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(front!=NULL) dequeue();\r",
				"    return 0;\r",
				"}\r",
				""
			]
		},
		"insert at end of single linked list": {
			"prefix": "insert at end of linked list with head",
			"body": [
				"void insertll(int n) //insertion fxn made to add nodes\r",
				"{\r",
				"    node *temp =(node*)malloc(sizeof(node)); //used dynamic allocation\r",
				"    temp->data=n; \r",
				"    temp->next=NULL;\r",
				"    if (head==NULL)\r",
				"    {\r",
				"        head=temp;\r",
				"    }\r",
				"    else{\r",
				"        node *tempp=head;\r",
				"        for(;tempp->next!=NULL;) {\r",
				"            tempp=tempp->p;\r",
				"        }\r",
				"        tempp->next=temp;\r",
				"    }\r",
				"}"
			]
		},
		"traverse singly linked list": {
			"prefix": "traverse singly linked list",
			"body": [
				"void traverse(){//function for traversing the linked list\r",
				"\r",
				"    for(node*tempp=head;tempp!=NULL;tempp=tempp->next)//untill it encounters null,the loop will keep traversing\r",
				"    printf(\"%d \",tempp->data);\r",
				"}"
			]
		},
		"delete from singly linked list": {
			"prefix": "delete from singly linked list",
			"body": [
				"void del(int n){//function for delete the given node from the linked list\r",
				"    if(head->data==n){//if node at head is to be deleted\r",
				"        node *tempp=head->next;\r",
				"        free(head);\r",
				"        head=tempp;\r",
				"    }\r",
				"    else//other cases\r",
				"    for(node *tempp=head;tempp->next!=NULL;tempp=tempp->next){\r",
				"        if(tempp->next->data==n){\r",
				"            node *nodetobedel=tempp->next;\r",
				"            tempp->next=tempp->next->next;\r",
				"            free(nodetobedel);\r",
				"            return;\r",
				"        }\r",
				"    }  \r",
				"}"
			]
		},
		"min and max single linked list": {
			"prefix": "minimum and maximum singly linked list",
			"body": [
				"void minandmax(){//function to find min and max node and print it\r",
				"    int max=0,min=head->data;//initially taking max and min default value\r",
				"     for(node*tempp=head;tempp!=NULL;tempp=tempp->next){//loop untill it gets null value\r",
				"         if(max< tempp->data){//condition for max\r",
				"             max=tempp->data;\r",
				"         }\r",
				"        if(min> tempp->data) {//condition for min\r",
				"            min=tempp->data;\r",
				"        }\r",
				"     }\r",
				"     printf(\"%d %d\",min,max);\r",
				"}"
			]
		},
		"doubly linked list struct": {
			"prefix": "struct doubly linked list circular",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h> //included lib\r",
				"#include<math.h>\r",
				"\r",
				"struct Node //initialised a linked list\r",
				"{\r",
				"    struct Node *last;\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"\r",
				"typedef struct Node node;\r",
				"node* tail=NULL;"
			]
		},
		"insert at beginning circular doubly linked list": {
			"prefix": "insert at beginning circular doubly linked list",
			"body": [
				"node *addemp(int data)\r",
				"{ // for adding to empty list\r",
				"    node *tmp = malloc(sizeof(node));\r",
				"    tmp->last = tmp;\r",
				"    tmp->data = data;\r",
				"    tmp->next = tmp;\r",
				"    return tmp;\r",
				"}\r",
				"node *insertatbeg(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        tail = p;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *tmp = tail->next; // nodes declared\r",
				"        node *tmp1 = tmp->next;\r",
				"        p->last = tail;\r",
				"        p->next = tmp;\r",
				"        tmp->last = p;\r",
				"        tail->next = p;\r",
				"        return tail;\r",
				"    }\r",
				"}"
			]
		},
		"empty circular doubly node added": {
			"prefix": "circular doubly add empty",
			"body": [
				"node *addemp(int data)\r",
				"{ // for adding to empty list\r",
				"    node *tmp = malloc(sizeof(node));\r",
				"    tmp->last = tmp;\r",
				"    tmp->data = data;\r",
				"    tmp->next = tmp;\r",
				"    return tmp;\r",
				"}"
			]
		},
		"insert at end circular doubly linked list": {
			"prefix": "insert at end circular doubly",
			"body": [
				"node *insertatend(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        tail = p;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *tmp = tail->next; // nodes declared\r",
				"        node *tmp1 = tmp->next;\r",
				"        p->last = tail;\r",
				"        p->next = tmp;\r",
				"        tmp->last = p;\r",
				"        tail->next = p;\r",
				"        tail=p;\r",
				"        return tail;\r",
				"    }\r",
				"}"
			]
		},
		"neighbours of doubly linked list members": {
			"prefix": "neighbours of doubly linked list members",
			"body": [
				"void neighbours(int num)\r",
				"{\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        printf(\"No elements/null\");\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *temp = tail->next; // node initialised\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // while traversing, once it finds the data=data of node,it ll print last and next as the neighbour\r",
				"                printf(\"%d %d\", temp->last->data, temp->next->data);\r",
				"                return;\r",
				"            }\r",
				"            temp = temp->next;\r",
				"        } while (temp != tail->next);\r",
				"    }\r",
				"}"
			]
		},
		"delete from circular doubly linked list": {
			"body": [
				"void del(int num)\r",
				"{ // fxn for deletion of specific data from the linked list\r",
				"    int count = 0;\r",
				"    node *temp = tail->next;  // node initialised\r",
				"    node *temp2 = temp->next; // node initialised 2nd node\r",
				"    node *temp1 = tail->last; // node initialised second last node\r",
				"    if (num == temp->data)\r",
				"    { // if 1st node is to be deleted\r",
				"        tail->next = temp2;\r",
				"        temp->next->last = tail;\r",
				"        free(temp);\r",
				"    }\r",
				"    else if (num == tail->data)\r",
				"    { // if last node is to be deleted\r",
				"        temp1->next = tail->next;\r",
				"        tail->next->last = temp1;\r",
				"        free(tail);\r",
				"        tail = temp1;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // traversing till we find the data in linked list\r",
				"                node *temp2 = temp->last;\r",
				"                temp2->next = temp->next;\r",
				"                temp->next->last = temp2;\r",
				"                free(temp);\r",
				"                count++;\r",
				"            }\r",
				"            else\r",
				"            {\r",
				"                temp = temp->next; // otherwise it ll continue traversing\r",
				"                temp2 = temp2->next;\r",
				"            }\r",
				"        } while ((temp != tail->next) && (count == 0));\r",
				"    }\r",
				"}"
			]
		},
		"delete from circular doubly linked list_01c9568d-6805-4318-b581-ae82c88823f2": {
			"prefix": "delete from circular doubly linked list",
			"body": [
				"void del(int num)\r",
				"{ // fxn for deletion of specific data from the linked list\r",
				"    int count = 0;\r",
				"    node *temp = tail->next;  // node initialised\r",
				"    node *temp2 = temp->next; // node initialised 2nd node\r",
				"    node *temp1 = tail->last; // node initialised second last node\r",
				"    if (num == temp->data)\r",
				"    { // if 1st node is to be deleted\r",
				"        tail->next = temp2;\r",
				"        temp->next->last = tail;\r",
				"        free(temp);\r",
				"    }\r",
				"    else if (num == tail->data)\r",
				"    { // if last node is to be deleted\r",
				"        temp1->next = tail->next;\r",
				"        tail->next->last = temp1;\r",
				"        free(tail);\r",
				"        tail = temp1;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // traversing till we find the data in linked list\r",
				"                node *temp2 = temp->last;\r",
				"                temp2->next = temp->next;\r",
				"                temp->next->last = temp2;\r",
				"                free(temp);\r",
				"                count++;\r",
				"            }\r",
				"            else\r",
				"            {\r",
				"                temp = temp->next; // otherwise it ll continue traversing\r",
				"                temp2 = temp2->next;\r",
				"            }\r",
				"        } while ((temp != tail->next) && (count == 0));\r",
				"    }\r",
				"}"
			]
		},
		"stack struct": {
			"prefix": "stack struct",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"\r",
				"struct node\r",
				"{\r",
				"\r",
				"char data;\r",
				"struct node *next;\r",
				"\r",
				"\r",
				"}*top=NULL"
			]
		},
		"stack push": {
			"prefix": "push stack",
			"body": [
				"void push (char symbol)\r",
				"{\r",
				"\r",
				"    struct node *p;\r",
				"    p=(struct node *)malloc(sizeof(struct node));\r",
				"    p->data=symbol;\r",
				"    if(top==NULL)\r",
				"    {\r",
				"     top=p;\r",
				"     p->next=NULL;\r",
				"\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"\r",
				"    p->next=top;\r",
				"    top=p;\r",
				"\r",
				"    }\r",
				"}"
			]
		},
		"pop stack": {
			"prefix": "stack pop",
			"body": [
				"char  pop()\r",
				"{\r",
				"struct node *tempp;\r",
				"char k;\r",
				"if(top==NULL)\r",
				"{\r",
				"    printf(\"stack underflow\\n\");\r",
				"    return 0;\r",
				"\r",
				"}\r",
				"else\r",
				"{\r",
				"tempp=top;\r",
				"top=top->next;\r",
				"k=tempp->data;\r",
				"//printf(\"node %d is deleted\\n\",top->data);\r",
				"free(tempp);\r",
				"tempp=NULL;\r",
				"return k;\r",
				"\r",
				"\r",
				"}}"
			]
		},
		"inftopostfix": {
			"prefix": "infix postfix",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"\r",
				"struct node\r",
				"{\r",
				"\r",
				"char data;\r",
				"struct node *next;\r",
				"\r",
				"\r",
				"}*top=NULL,*pstart=NULL;\r",
				"/*-------------------- insertion in postfix expression linked list -------*/\r",
				"\r",
				"\r",
				"void insert(char ch)\r",
				"{\r",
				"struct node *t,*baby;\r",
				"    baby=(struct node *)malloc(sizeof(struct node));\r",
				"    baby->next=NULL;\r",
				"    baby->data=ch;\r",
				"    t=pstart;\r",
				"\r",
				"    if(pstart==NULL)\r",
				"    {\r",
				"    pstart=baby;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"    while(t->next!=NULL)\r",
				"    t=t->next;\r",
				"    t->next=baby;\r",
				"\r",
				"    }\r",
				"    //printf(\" inserted in list- %c\",baby->data);\r",
				"\r",
				"}\r",
				"\r",
				"/* --------- push operation ------- */\r",
				"\r",
				"\r",
				"\r",
				"void push (char symbol)\r",
				"{\r",
				"\r",
				"    struct node *p;\r",
				"    p=(struct node *)malloc(sizeof(struct node));\r",
				"    p->data=symbol;\r",
				"    if(top==NULL)\r",
				"    {\r",
				"     top=p;\r",
				"     p->next=NULL;\r",
				"\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"\r",
				"    p->next=top;\r",
				"    top=p;\r",
				"\r",
				"    }\r",
				"}\r",
				"\r",
				"char  pop()\r",
				"{\r",
				"struct node *x,*y;\r",
				"char k;\r",
				"if(top==NULL)\r",
				"{\r",
				"    printf(\"stack underflow\\n\");\r",
				"    return 0;\r",
				"\r",
				"}\r",
				"else\r",
				"{\r",
				"x=top;\r",
				"top=top->next;\r",
				"k=x->data;\r",
				"//printf(\"node %d is deleted\\n\",top->data);\r",
				"free(x);\r",
				"x=NULL;\r",
				"return k;\r",
				"\r",
				"\r",
				"}\r",
				"\r",
				"\r",
				"\r",
				"}\r",
				"\r",
				"\r",
				"void displaypost()\r",
				"{\r",
				"    struct node *to;\r",
				"    if(pstart==NULL)\r",
				"    printf(\"\");\r",
				"    else\r",
				"    {\r",
				"    to=pstart;\r",
				"    while(to!=NULL)\r",
				"    {\r",
				"        printf(\"%c\",to->data);\r",
				"        to=to->next;\r",
				"\r",
				"    }\r",
				"\r",
				"    }\r",
				"\r",
				"\r",
				"}\r",
				"\r",
				"\r",
				"/*============== precedence selector ================= */\r",
				"\r",
				"int precedence(char ch)\r",
				"{\r",
				"\r",
				"if(ch=='^')\r",
				"return (5);\r",
				"else if(ch=='*' || ch== '/')\r",
				"return (4);\r",
				"else if (ch== '+' || ch== '-')\r",
				"return (3);\r",
				"else\r",
				"return (2);\r",
				"}\r",
				"\r",
				"\r",
				"/*=================== infix to postfix conversion ================ */\r",
				"\r",
				"void intopost(char infix[])\r",
				"{\r",
				"\r",
				"    int len;\r",
				"    int index=0;\r",
				"    char symbol,temp;\r",
				"    len= strlen(infix);\r",
				"    //printf(\"%d\",len);\r",
				"    while(len>index)\r",
				"    {\r",
				"        symbol=infix[index];\r",
				"\r",
				"        switch(symbol)\r",
				"        {\r",
				"\r",
				"        case '(':\r",
				"        push(symbol);\r",
				"        break;\r",
				"\r",
				"        case ')':\r",
				"        // temp=pop();\r",
				"        while(temp!='(')\r",
				"        {\r",
				"        insert(temp);\r",
				"        temp=pop();\r",
				"        }\r",
				"        break;\r",
				"\r",
				"        case '^':\r",
				"        case '+':\r",
				"        case '-':\r",
				"        case '*':\r",
				"        case '/':\r",
				"        if(top==NULL)\r",
				"        {\r",
				"            push(symbol);\r",
				"    //      break;\r",
				"\r",
				"        }\r",
				"        else\r",
				"        {\r",
				"        while(top!=NULL && (precedence(top->data)>=precedence(symbol)))\r",
				"        {\r",
				"            temp=pop();\r",
				"            insert(temp);\r",
				"\r",
				"        }\r",
				"        push(symbol);\r",
				"\r",
				"        }   \r",
				"        break;\r",
				"        default:\r",
				"        insert(symbol);\r",
				"\r",
				"         }\r",
				"         index=index+1;\r",
				"\r",
				"\r",
				"    }\r",
				"    while(top!=NULL)\r",
				"    {\r",
				"    temp=pop();\r",
				"    insert(temp);\r",
				"\r",
				"    }\r",
				"    displaypost();\r",
				"    return;\r",
				"\r",
				"\r",
				"\r",
				"\r",
				"}\r",
				"\r",
				"\r",
				"int main()\r",
				"{\r",
				"char infix[50];\r",
				"scanf(\"%s\",infix);\r",
				"intopost(infix);\r",
				"getchar();\r",
				"return 0;\r",
				"}"
			]
		},
		"reverseastring": {
			"prefix": "reverse a string",
			"body": [
				"#include <stdio.h>\r",
				"#include <stdlib.h>\r",
				"#include <string.h>\r",
				"struct Node\r",
				"{\r",
				"    int data;\r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *top = NULL;\r",
				"void push(char character)\r",
				"{\r",
				"\r",
				"    node *p;\r",
				"    p = (node *)malloc(sizeof(node *));\r",
				"    p->data = character;\r",
				"    if (top == NULL)\r",
				"    {\r",
				"        top = p;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"\r",
				"        p->next = top;\r",
				"        top = p;\r",
				"    }\r",
				"}\r",
				"\r",
				"char pop()\r",
				"{\r",
				"    node *tempp;\r",
				"    char k;\r",
				"    if (top == NULL)\r",
				"    {\r",
				"        printf(\"stack underflow\\n\");\r",
				"        return 0;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        tempp = top;\r",
				"        top = top->next;\r",
				"        k = tempp->data;\r",
				"        // printf(\"node %d is deleted\\n\",top->data);\r",
				"        free(tempp);\r",
				"        return k;\r",
				"    }\r",
				"}\r",
				"\r",
				"void reversestring(char str[])\r",
				"{\r",
				"    for (int i = 0;strlen(str)>i;i++)\r",
				"    {\r",
				"        push(str[i]);\r",
				"    }\r",
				"    for(int i=0;(top!=NULL)&&(strlen(str)>i);i++)\r",
				"    {\r",
				"        str[i] = pop();\r",
				"    }\r",
				"    for (int i = 0;strlen(str)>i;i++)\r",
				"    {\r",
				"        printf(\"%c\", str[i]);\r",
				"    }\r",
				"\r",
				"}\r",
				"int main(void)\r",
				"{\r",
				"    char str[100];\r",
				"    fgets(str,100,stdin);\r",
				"    reversestring(str);\r",
				"\r",
				"}"
			]
		},
		"stack operations": {
			"prefix": "stack using LL",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"\r",
				"struct Node //created a struct for linked list that will act as stack\r",
				"{\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *top=NULL;//initialised top..in our stack using linked list...head will act as top and node at beginning will act as top\r",
				"\r",
				"//push fxn\r",
				"void push(int data){\r",
				"    node* ptr=malloc(sizeof(node));//declared node that will store the data\r",
				"    ptr->data=data;\r",
				"    if(top==NULL){//empty stack condition\r",
				"        ptr->next=NULL;\r",
				"        top=ptr;\r",
				"    }\r",
				"    else{\r",
				"        ptr->next=top;\r",
				"        top=ptr;//now top will point to the newly added node\r",
				"    }\r",
				"}\r",
				"//pop fxn\r",
				"void pop(){\r",
				"    node* temp=top;\r",
				"    if(top==NULL){//empty stack condition\r",
				"        printf(\"stack underflow\");\r",
				"    }\r",
				"    else{\r",
				"        printf(\"%d\",top->data);\r",
				"        top=top->next;\r",
				"        free(temp);\r",
				"    }\r",
				"}\r",
				"//note: for traversing/checking the stack you can run this code below\r",
				"void print(){\r",
				"    if(top==NULL){\r",
				"        printf(\"stack underflow\");\r",
				"    }\r",
				"    else{\r",
				"   for(node* tempp=top;tempp!=NULL;tempp=tempp->next){\r",
				"       printf(\"%d \",tempp->data );\r",
				"   }\r",
				"   printf(\"\\n\");}\r",
				"}\r",
				"int isempty(){\r",
				"    return (top==NULL);\r",
				"}\r",
				"\r",
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='P'){\r",
				"            scanf(\"%d\" ,&data);//element to be pushed in stack taken as input\r",
				"            push(data);//calling function\r",
				"        }\r",
				"        else if (func=='p'){\r",
				"            pop();//calling function\r",
				"            printf(\"\\n\");\r",
				"        }\r",
				"        else if(func=='t'){\r",
				"            print();\r",
				"        }\r",
				"        else if(func=='e'){\r",
				"            if(isempty()){\r",
				"                printf(\"yes\\n\");\r",
				"            }\r",
				"            else{\r",
				"                printf(\"no\\n\");\r",
				"            }\r",
				"        }\r",
				"\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(top!=NULL) pop();\r",
				"    return 0;\r",
				"}\r",
				"\r",
				""
			]
		},
		"Linked list operations": {
			"prefix": "ll operation",
			"body": [
				"#include<stdio.h>\r",
				"#include<math.h>\r",
				"#include<stdlib.h>\r",
				"\r",
				"struct Node //created a struct for linked list\r",
				"{\r",
				"    int data; \r",
				"    struct Node *p;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *head=NULL;//initialised head(start)\r",
				"\r",
				"\r",
				"\r",
				"void insertll(int n) //insertion fxn made to add nodes\r",
				"{\r",
				"    node *temp =(node*)malloc(sizeof(node)); //used dynamic allocation\r",
				"    temp->data=n; \r",
				"    temp->p=NULL;\r",
				"    if (head==NULL)\r",
				"    {\r",
				"        head=temp;\r",
				"    }\r",
				"    else{\r",
				"        node *tempp=head;\r",
				"        for(;tempp->p!=NULL;) {\r",
				"            tempp=tempp->p;\r",
				"        }\r",
				"        tempp->p=temp;\r",
				"    }\r",
				"}\r",
				"\r",
				"\r",
				"\r",
				"void traverse(){//function for traversing the linked list\r",
				"\r",
				"    for(node*tempp=head;tempp!=NULL;tempp=tempp->p)//untill it encounters null,the loop will keep traversing\r",
				"    printf(\"%d \",tempp->data);\r",
				"}\r",
				"\r",
				"\r",
				"\r",
				"void delt(int n){//function for delete the given node from the linked list\r",
				"    if(head->data==n){//if node at head is to be deleted\r",
				"        node *tempp=head->p;\r",
				"        free(head);\r",
				"        head=tempp;\r",
				"    }\r",
				"    else//other cases\r",
				"    for(node *tempp=head;tempp->p!=NULL;tempp=tempp->p){\r",
				"        if(tempp->p->data==n){\r",
				"            node *aptr=tempp->p;\r",
				"            tempp->p=tempp->p->p;\r",
				"            free(aptr);\r",
				"            return;\r",
				"        }\r",
				"    }  \r",
				"}\r",
				"\r",
				"\r",
				"\r",
				"void minandmax(){//function to find min and max node and print it\r",
				"    int max=0,min=head->data;//initially taking max and min default value\r",
				"     for(node*tempp=head;tempp!=NULL;tempp=tempp->p){//loop untill it gets null value\r",
				"         if(max< tempp->data){//condition for max\r",
				"             max=tempp->data;\r",
				"         }\r",
				"        if(min> tempp->data) {//condition for min\r",
				"            min=tempp->data;\r",
				"        }\r",
				"     }\r",
				"     printf(\"%d %d\",min,max);\r",
				"}\r",
				"\r",
				"\r",
				"//Main function\r",
				"int main(void){   \r",
				"    char resp=0;\r",
				"    int num;\r",
				"    while (resp!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&resp);//fxns to be called as per the input\r",
				"        if (resp=='i'){\r",
				"            scanf(\"%d\" ,&num);//element to be inserted taken as input\r",
				"            insertll(num);//calling function\r",
				"        }\r",
				"        else if (resp=='t'){\r",
				"            traverse();//calling function\r",
				"        printf(\"\\n\");\r",
				"        }\r",
				"        else if (resp=='d'){\r",
				"            scanf(\"%d\", &num);//element to be deleted taken as input\r",
				"            delt(num);//calling function\r",
				"        }\r",
				"        else if(resp=='m'){\r",
				"            minandmax();\r",
				"        printf(\"\\n\");//calling function\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(head!=NULL) delt(head->data);\r",
				"    return 0;\r",
				"}"
			]
		},
		"linear queue operations": {
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"int c=1;//it ll decide whether popped value needs to be printed or not(if empty queue,else it would print -1)\r",
				"struct Node //created a struct for linked list that will act as stack\r",
				"{\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *front=NULL;\r",
				"node *end=NULL;\r",
				"\r",
				"void enqueue(int data){\r",
				"    node* ptr=malloc(sizeof(node));//declared node that will store the data\r",
				"    ptr->data=data;\r",
				"    ptr->next=NULL;\r",
				"    if((front==NULL)&&(end==NULL)){//empty stack condition\r",
				"        front=ptr;\r",
				"        end=ptr;\r",
				"    }\r",
				"    else{\r",
				"        end->next=ptr;\r",
				"        end=end->next;//now top will point to the newly added node\r",
				"    }\r",
				"}\r",
				"int dequeue(){\r",
				"    node* temp=front;\r",
				"    if(front==NULL){//empty stack condition\r",
				"        printf(\"empty queue\\n\");\r",
				"        c=0;\r",
				"        return -1;\r",
				"    }\r",
				"    else{\r",
				"        c=1;\r",
				"        // printf(\"%d\",top->data);\r",
				"        int x=front->data;\r",
				"        front=front->next;\r",
				"        if(front==NULL){\r",
				"            end=NULL;\r",
				"        }\r",
				"\r",
				"        free(temp);\r",
				"        return(x);\r",
				"    }\r",
				"}\r",
				"// note: use this to see changesin queue\r",
				"void print(){\r",
				"    if((front==NULL)&&(end==NULL)){\r",
				"        printf(\"queue empty\");\r",
				"    }\r",
				"    else{\r",
				"        printf(\" front: %d\\n\",front->data);\r",
				"         printf(\" end: %d\\n\",end->data);\r",
				"   for(node* tempp=front;tempp!=NULL;tempp=tempp->next){\r",
				"       printf(\"%d \",tempp->data );\r",
				"   }\r",
				"   printf(\"\\n\");}\r",
				"}\r",
				"\r",
				"\r",
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    int value;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='e'){\r",
				"            scanf(\"%d\" ,&data);//element to be pushed in stack taken as input\r",
				"            enqueue(data);//calling function\r",
				"        }\r",
				"        else if (func=='d'){\r",
				"            value=dequeue();//calling function\r",
				"            if(c==1){printf(\"%d\\n\",value);}\r",
				"        }\r",
				"        else if(func=='t'){\r",
				"            print();\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(front!=NULL) dequeue();\r",
				"    return 0;\r",
				"}\r",
				""
			]
		},
		"linear queue operations_cf3a0d7b-a349-455c-b3ec-e42fef9be907": {
			"prefix": "operations linear queue",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"int c=1;//it ll decide whether popped value needs to be printed or not(if empty queue,else it would print -1)\r",
				"struct Node //created a struct for linked list that will act as stack\r",
				"{\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *front=NULL;\r",
				"node *end=NULL;\r",
				"\r",
				"void enqueue(int data){\r",
				"    node* ptr=malloc(sizeof(node));//declared node that will store the data\r",
				"    ptr->data=data;\r",
				"    ptr->next=NULL;\r",
				"    if((front==NULL)&&(end==NULL)){//empty stack condition\r",
				"        front=ptr;\r",
				"        end=ptr;\r",
				"    }\r",
				"    else{\r",
				"        end->next=ptr;\r",
				"        end=end->next;//now top will point to the newly added node\r",
				"    }\r",
				"}\r",
				"int dequeue(){\r",
				"    node* temp=front;\r",
				"    if(front==NULL){//empty stack condition\r",
				"        printf(\"empty queue\\n\");\r",
				"        c=0;\r",
				"        return -1;\r",
				"    }\r",
				"    else{\r",
				"        c=1;\r",
				"        // printf(\"%d\",top->data);\r",
				"        int x=front->data;\r",
				"        front=front->next;\r",
				"        if(front==NULL){\r",
				"            end=NULL;\r",
				"        }\r",
				"\r",
				"        free(temp);\r",
				"        return(x);\r",
				"    }\r",
				"}\r",
				"// note: use this to see changesin queue\r",
				"void print(){\r",
				"    if((front==NULL)&&(end==NULL)){\r",
				"        printf(\"queue empty\");\r",
				"    }\r",
				"    else{\r",
				"        printf(\" front: %d\\n\",front->data);\r",
				"         printf(\" end: %d\\n\",end->data);\r",
				"   for(node* tempp=front;tempp!=NULL;tempp=tempp->next){\r",
				"       printf(\"%d \",tempp->data );\r",
				"   }\r",
				"   printf(\"\\n\");}\r",
				"}\r",
				"\r",
				"\r",
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    int value;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='e'){\r",
				"            scanf(\"%d\" ,&data);//element to be pushed in stack taken as input\r",
				"            enqueue(data);//calling function\r",
				"        }\r",
				"        else if (func=='d'){\r",
				"            value=dequeue();//calling function\r",
				"            if(c==1){printf(\"%d\\n\",value);}\r",
				"        }\r",
				"        else if(func=='t'){\r",
				"            print();\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(front!=NULL) dequeue();\r",
				"    return 0;\r",
				"}"
			]
		},
		"printing circular doubly linked list": {
			"prefix": "print circular doubly linked list",
			"body": [
				"void printdata(){\r",
				"    if(tail==NULL){\r",
				"        printf(\"no node\");\r",
				"        }\r",
				"    else{\r",
				"            node*temp=tail->next;\r",
				"            do{\r",
				"                printf(\"%d \",temp->data);\r",
				"                temp=temp->next;\r",
				"            }while(temp!=tail->next);\r",
				"        }\r",
				"\r",
				"}"
			]
		},
		"doubly circular linked list operations": {
			"prefix": "circular doubly linked list",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h> //included lib\r",
				"#include<math.h>\r",
				"\r",
				"struct Node //initialised a linked list\r",
				"{\r",
				"    struct Node *last;\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"\r",
				"typedef struct Node node;\r",
				"node* tail=NULL;\r",
				"\r",
				"node *addemp(int data)\r",
				"{ // for adding to empty list\r",
				"    node *tmp = malloc(sizeof(node));\r",
				"    tmp->last = tmp;\r",
				"    tmp->data = data;\r",
				"    tmp->next = tmp;\r",
				"    return tmp;\r",
				"}\r",
				"node *addemp(int data)\r",
				"{ // for adding to empty list\r",
				"    node *tmp = malloc(sizeof(node));\r",
				"    tmp->last = tmp;\r",
				"    tmp->data = data;\r",
				"    tmp->next = tmp;\r",
				"    return tmp;\r",
				"}\r",
				"node *insertatbeg(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        tail = p;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *tmp = tail->next; // nodes declared\r",
				"        node *tmp1 = tmp->next;\r",
				"        p->last = tail;\r",
				"        p->next = tmp;\r",
				"        tmp->last = p;\r",
				"        tail->next = p;\r",
				"        return tail;\r",
				"    }\r",
				"}\r",
				"\r",
				"node *insertatend(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        tail = p;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *tmp = tail->next; // nodes declared\r",
				"        node *tmp1 = tmp->next;\r",
				"        p->last = tail;\r",
				"        p->next = tmp;\r",
				"        tmp->last = p;\r",
				"        tail->next = p;\r",
				"        tail=p;\r",
				"        return tail;\r",
				"    }\r",
				"}\r",
				"void del(int num)\r",
				"{ // fxn for deletion of specific data from the linked list\r",
				"    int count = 0;\r",
				"    node *temp = tail->next;  // node initialised\r",
				"    node *temp2 = temp->next; // node initialised 2nd node\r",
				"    node *temp1 = tail->last; // node initialised second last node\r",
				"    if (num == temp->data)\r",
				"    { // if 1st node is to be deleted\r",
				"        tail->next = temp2;\r",
				"        temp->next->last = tail;\r",
				"        free(temp);\r",
				"    }\r",
				"    else if (num == tail->data)\r",
				"    { // if last node is to be deleted\r",
				"        temp1->next = tail->next;\r",
				"        tail->next->last = temp1;\r",
				"        free(tail);\r",
				"        tail = temp1;\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // traversing till we find the data in linked list\r",
				"                node *temp2 = temp->last;\r",
				"                temp2->next = temp->next;\r",
				"                temp->next->last = temp2;\r",
				"                free(temp);\r",
				"                count++;\r",
				"            }\r",
				"            else\r",
				"            {\r",
				"                temp = temp->next; // otherwise it ll continue traversing\r",
				"                temp2 = temp2->next;\r",
				"            }\r",
				"        } while ((temp != tail->next) && (count == 0));\r",
				"    }\r",
				"}\r",
				"\r",
				"void printdata(){\r",
				"    if(tail==NULL){\r",
				"        printf(\"no node\");\r",
				"        }\r",
				"    else{\r",
				"            node*temp=tail->next;\r",
				"            do{\r",
				"                printf(\"%d \",temp->data);\r",
				"                temp=temp->next;\r",
				"            }while(temp!=tail->next);\r",
				"        }\r",
				"\r",
				"}\r",
				"void neighbours(int num)\r",
				"{\r",
				"    if (tail == NULL)\r",
				"    { // null case\r",
				"        printf(\"No elements/null\");\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        node *temp = tail->next; // node initialised\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // while traversing, once it finds the data=data of node,it ll print last and next as the neighbour\r",
				"                printf(\"%d %d\", temp->last->data, temp->next->data);\r",
				"                return;\r",
				"            }\r",
				"            temp = temp->next;\r",
				"        } while (temp != tail->next);\r",
				"    }\r",
				"}"
			]
		},
		"linear doubly linked list": {
			"prefix": "linear doubly linked list",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h> //included lib\r",
				"#include<math.h>\r",
				"\r",
				"struct Node //initialised a linked list\r",
				"{\r",
				"    struct Node *last;\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"\r",
				"typedef struct Node node;\r",
				"node * head=NULL;\r",
				"node* tail=NULL;\r",
				"\r",
				"node *addemp(int data)\r",
				"{ // for adding to empty list\r",
				"    node *tmp = malloc(sizeof(node));\r",
				"    tmp->last = NULL;\r",
				"    tmp->data = data;\r",
				"    tmp->next = NULL;\r",
				"    return tmp;\r",
				"}\r",
				"\r",
				"void insertatbeg(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if ((tail == NULL)&(head==NULL))\r",
				"    { // null case\r",
				"        tail = p;\r",
				"        head =p;\r",
				"    }\r",
				"    else\r",
				"    {   node * temp=head;\r",
				"        p->last = NULL;\r",
				"        p->next = head;\r",
				"        temp->last=p;\r",
				"        head=p;\r",
				"    }\r",
				"}\r",
				"void insertatend(int data)\r",
				"{\r",
				"    node *p = addemp(data);\r",
				"    if ((tail == NULL)&(head==NULL))\r",
				"    { // null case\r",
				"        tail = p;\r",
				"        head= p;\r",
				"    }\r",
				"    else\r",
				"    {   node* temp=tail;\r",
				"        p->last = tail;\r",
				"        p->next = NULL;\r",
				"        temp->next = p;\r",
				"        tail=p;\r",
				"    }\r",
				"}\r",
				"int del(int num)\r",
				"{ // fxn for deletion of specific data from the linked list\r",
				"    int count = 0;\r",
				"     node* temp=head;\r",
				"     node* temp3=tail;\r",
				"     node* temp2=head->next;\r",
				"    node *temp1 = tail->last; // node initialised second last node\r",
				"    if (num == head->data)\r",
				"    { // if 1st node is to be deleted\r",
				"\r",
				"        head= head->next;\r",
				"        free(temp);\r",
				"    }\r",
				"    else if (num == tail->data)\r",
				"    { // if last node is to be deleted\r",
				"        tail->last->next=NULL;\r",
				"        tail = temp1;\r",
				"        free(temp3);\r",
				"    }\r",
				"    else\r",
				"    {\r",
				"        do\r",
				"        {\r",
				"            if (temp->data == num)\r",
				"            { // traversing till we find the data in linked list\r",
				"                node *temp2 = temp->last;\r",
				"                temp2->next = temp->next;\r",
				"                temp->next->last = temp2;\r",
				"                free(temp);\r",
				"                count++;\r",
				"                return 0;\r",
				"            }\r",
				"            else\r",
				"            {\r",
				"                temp = temp->next; // otherwise it ll continue traversing\r",
				"                temp2 = temp2->next;\r",
				"            }\r",
				"        } while ((temp !=NULL) && (count == 0));\r",
				"        printf(\"not found\");\r",
				"    }\r",
				"\r",
				"}\r",
				"\r",
				"void printdata(){\r",
				"    if(tail==NULL){\r",
				"        printf(\"no node\");\r",
				"        }\r",
				"    else{\r",
				"            node*temp=head;\r",
				"            do{\r",
				"                printf(\"%d \",temp->data);\r",
				"                temp=temp->next;\r",
				"            }while(temp!=NULL);\r",
				"        }\r",
				"\r",
				"}\r",
				"int main(void)\r",
				"{\r",
				"    char func = 0;\r",
				"    int data;\r",
				"    while (func != 'x')\r",
				"    {                       //'x' will end the program,though it is not written\r",
				"        scanf(\"%c\", &func); // fxns to be called as per the insert\r",
				"        if (func == 'i')\r",
				"        {\r",
				"            scanf(\"%d\", &data); // element to be inserted taken as insert\r",
				"            insertatbeg(data);       // calling function\r",
				"        }\r",
				"        else if (func == 'b')\r",
				"        {\r",
				"            scanf(\"%d\", &data); // element to be inserted taken as insert\r",
				"            insertatend(data);       // calling function\r",
				"        }\r",
				"\r",
				"        else if (func == 'd')\r",
				"        {\r",
				"            scanf(\"%d\", &data); // element to be deleted taken as insert\r",
				"            del(data);          // calling function\r",
				"        }\r",
				"        // NOTE!!!!!!!!!-use this for any confusion( to print the linked list)\r",
				"        else if(func=='p'){\r",
				"            printdata();\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    return 0;\r",
				"}"
			]
		},
		"circular queue": {
			"prefix": "circular queue",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"struct Node \r",
				"{\r",
				"    int data; \r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *front=NULL;\r",
				"node *rear=NULL;\r",
				"\r",
				"void enqueue(int n) //insertion fxn made to add nodes\r",
				"{\r",
				"    node *temp =(node*)malloc(sizeof(node)); //used dynamic allocation\r",
				"    temp->data=n; \r",
				"    temp->next=NULL;\r",
				"    if ((rear==NULL)&&(front==NULL))\r",
				"    {\r",
				"        front=temp;\r",
				"        rear=temp;\r",
				"        rear->next=front;\r",
				"    }\r",
				"    else{\r",
				"        rear->next=temp;\r",
				"        temp->next=front;\r",
				"        rear=temp;\r",
				"    }\r",
				"}\r",
				"void dequeue(){//function for delete the given node from the linked list\r",
				"    if ((rear==NULL))\r",
				"    {\r",
				"        printf(\"queue underflow\");\r",
				"    }\r",
				"    else if(front==rear){\r",
				"        front=rear=NULL;\r",
				"    }\r",
				"    else{\r",
				"\r",
				"    node* temp=front;\r",
				"    front=front->next;\r",
				"    rear->next=front;\r",
				"    free(temp);\r",
				"    }\r",
				"}\r",
				"void print(){\r",
				"    if((front==NULL)&&(rear==NULL)){\r",
				"        printf(\"queue empty\");\r",
				"        }\r",
				"    else{\r",
				"            node*temp=front;\r",
				"            do{\r",
				"                printf(\"%d \",temp->data);\r",
				"                temp=temp->next;\r",
				"            }while(temp!=front);\r",
				"            printf(\"\\n\");\r",
				"        }\r",
				"\r",
				"}\r",
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    int value;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='e'){\r",
				"            scanf(\"%d\" ,&data);\r",
				"            enqueue(data);\r",
				"        }\r",
				"        else if (func=='d'){\r",
				"           dequeue();//calling function\r",
				"\r",
				"        }\r",
				"        else if(func=='t'){\r",
				"            print();\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(front!=NULL) dequeue();\r",
				"    return 0;\r",
				"}"
			]
		},
		"priority queue": {
			"prefix": "priority queue",
			"body": [
				"#include<stdio.h>\r",
				"#include<stdlib.h>\r",
				"#include<string.h>\r",
				"struct Node \r",
				"{\r",
				"    int data; \r",
				"    int priority;\r",
				"    struct Node *next;\r",
				"};\r",
				"typedef struct Node node;\r",
				"node *front=NULL;\r",
				"node *end =NULL;\r",
				"\r",
				"void enqueue(int data,int priority){\r",
				"    node* ptr=malloc(sizeof(node));//declared node that will store the data\r",
				"    ptr->data=data;\r",
				"    ptr->priority=priority;\r",
				"    if((front==NULL)){//empty stack condition\r",
				"        ptr->next=NULL;\r",
				"        front=ptr;\r",
				"        end=ptr;\r",
				"    }\r",
				"    else if((front->priority)>priority){\r",
				"        ptr->next=front;\r",
				"        front=ptr;\r",
				"    }\r",
				"    else if(end->priority<priority){\r",
				"        end->next=ptr;\r",
				"        ptr->priority=priority;\r",
				"        ptr->next=NULL;\r",
				"        end=ptr;\r",
				"\r",
				"    }\r",
				"    else{\r",
				"        node* temp=front;\r",
				"        while((temp!=NULL)&&(temp->next->priority<priority)){\r",
				"            temp=temp->next;\r",
				"        }\r",
				"        ptr->next=temp->next;\r",
				"        temp->next=ptr;\r",
				"    }\r",
				"}\r",
				"int dequeue(){\r",
				"    node* temp=front;\r",
				"    if(front==NULL){//empty stack condition\r",
				"        printf(\"empty queue\\n\");\r",
				"        return -1;\r",
				"    }\r",
				"    else{\r",
				"        int x=front->data;\r",
				"        front=front->next;\r",
				"\r",
				"        free(temp);\r",
				"        return(x);\r",
				"    }\r",
				"}\r",
				"// note: use this to see changesin queue\r",
				"void print(){\r",
				"    if((front==NULL)){\r",
				"        printf(\"queue empty\\n\");\r",
				"    }\r",
				"    else{\r",
				"        printf(\" front: %d\\n\",front->data);\r",
				"        printf(\" end: %d\\n\",end->data);\r",
				"   for(node* tempp=front;tempp!=NULL;tempp=tempp->next){\r",
				"       printf(\"%d \",tempp->data );\r",
				"   }\r",
				"   printf(\"\\n\");}\r",
				"}\r",
				"int main(void){   \r",
				"    char func=0;\r",
				"    int data;\r",
				"    int priority;\r",
				"    while (func!='x'){//'x' will end the program\r",
				"        scanf(\"%c\",&func);//fxns to be called on the basis of whats input is given\r",
				"        if (func=='e'){\r",
				"            scanf(\"%d\" ,&data);//element to be pushed in stack taken as input\r",
				"            scanf(\"%d\",&priority);\r",
				"            enqueue(data,priority);//calling function\r",
				"        }\r",
				"        else if (func=='d'){\r",
				"            dequeue();//calling function\r",
				"\r",
				"        }\r",
				"        else if(func=='t'){\r",
				"            print();\r",
				"        }\r",
				"        fflush(stdin);\r",
				"    }\r",
				"    while(front!=NULL) dequeue();\r",
				"    return 0;\r",
				"}"
			]
		}
}